#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ,               sensorTouch)
#pragma config(Sensor, dgtl8,  ,               sensorTouch)
#pragma config(Sensor, dgtl11, ,               sensorQuadEncoder)
#pragma config(Motor,  port1,           arm_right,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           top_left,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           claw_grab,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           bottom_left,   tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl4)
#pragma config(Motor,  port5,           side_wheel,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           top_right,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           claw_tilt,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           bottom_right,  tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl11)
#pragma config(Motor,  port9,           claw_slide,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          arm_left,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

// gets the maximum value of two
float max(float a,float b) {
	if (a>b) {
		return a;
		} else {
		return b;
	}
}

// gets the minimum value of two
float min(float a,float b) {
	if (a<b) {
		return a;
		} else {
		return b;
	}
}

// makes sure a value is within a range
float range(float n,float mn,float mx) {
	return max(min(n,mx),mn);
}

#include "movement.c"

int maxbt=0;
int mode=0;
int lcdmode=1;
task lcd() {
	bLCDBacklight=true;
	while (true) {
		/*switch (lcdmode) {
			case 0:
				clearLCDLine(0);
				clearLCDLine(1);
			break;
			case 1:
				/*char top[16];
				char bottom[16];
				int cur=nImmediateBatteryLevel;
				maxbt=maxbt>cur?maxbt:cur;
				snprintf(top,16,"Battery: %i.%iv",cur/1000,(cur%1000)/10);
				int lost=maxbt-cur;
				snprintf(bottom,16,"Lost: %i.%iv",lost/1000,(lost%1000)/10);
				displayLCDCenteredString(0,top);
				displayLCDCenteredString(1,bottom);
			break;
			case 2:
				char top[16];
				char bottom[16];
				int cur=nImmediateBatteryLevel;
				maxbt=maxbt>cur?maxbt:cur;
				snprintf(top,16,"Battery: %i.%iv",cur/1000,(cur%1000)/10);
				displayLCDCenteredString(0,top);
				snprintf(bottom,16,"Mode: %d",mode);
				displayLCDCenteredString(1,bottom);
			break;
		}*/
		char top[16];
		char bottom[16];
		snprintf(top,16,"R %i",getMotorEncoder(bottom_right));
		displayLCDCenteredString(0,top);
		snprintf(bottom,16,"L %i",getMotorEncoder(bottom_left));
		displayLCDCenteredString(1,bottom);
		wait1Msec(100);
	}
}

int reversed=-1;

int autonMode() {
	reversed=(SensorValue[dgtl7]*2)-1;
	if (SensorValue[dgtl8]) {
		return 2;
	}
	return 1;
}

task showAuton() {
	while (true) {
		wait1Msec(1500);
		autonMode();
		if (true) {
			if (reversed==1) {
				SensorValue[led1]=true;
				wait1Msec(500);
				SensorValue[led1]=false;
				wait1Msec(150);
			}
			for (int i=0;i<autonMode();i++) {
				SensorValue[led1]=true;
				wait1Msec(150);
				SensorValue[led1]=false;
				wait1Msec(150);
			}
		} else {
			SensorValue[led1]=false;
		}
	}
}

void pre_auton()
{
	lcdmode=1;
	startTask(showAuton);
	startTask(lcd);
	bStopTasksBetweenModes = true;
}

void armDirect(int pow) {
	motor[arm_left]=pow;
	motor[arm_right]=pow;
};

void armUp(float time) {
	motor[arm_left]=127;
	motor[arm_right]=127;
	wait1Msec(time*1000);
	motor[arm_left]=0;
	motor[arm_right]=0;
}

void armDown(float time) {
	motor[arm_left]=-127;
	motor[arm_right]=-127;
	wait1Msec(time*1000);
	motor[arm_left]=0;
	motor[arm_right]=0;
}

void slideUp(float time) {
	motor[claw_slide]=127;
	wait1Msec(time*1000);
	motor[claw_slide]=0;
}

void slideDown(float time) {
	motor[claw_slide]=-127;
	wait1Msec(time*1000);
	motor[claw_slide]=0;
}

void clawUp(float time) {
	motor[claw_tilt]=127;
	wait1Msec(time*1000);
	motor[claw_tilt]=0;
}

void clawDown(float time) {
	motor[claw_tilt]=-127;
	wait1Msec(time*1000);
	motor[claw_tilt]=0;
}

void clawGrab() {
	motor[claw_grab]=127;
	wait1Msec(1000);
	motor[claw_grab]=0;
}

void clawRelease() {
	motor[claw_grab]=-127;
	wait1Msec(1000);
	motor[claw_grab]=0;
}

int getBtns(int btn1, int btn2) {
	return (vexRT[btn1]*128)+(vexRT[btn2]*-128);
}

int last[32]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int getBtn(int btn) {
	if (last[btn]!=vexRT[btn]) {
		last[btn]=vexRT[btn];
		return vexRT[btn];
	}
	return 0;
}

/*task autonomous() {
	lcdmode=1;
	switch (autonMode()) {
		case 1:
			slideUp(0.5);
			clawGrab();
			armUp(3);
			turnLeft(0.4);
			armDown(2);
			clawRelease();
			back(0.2);
			clawDown(1);
			back(1);
		break;
		case 2:
			slideUp(0.5);
			clawDown(1.4);
			forward(0.5);
			clawRelease();
			turnLeft(1);
			clawGrab();
			back(1);
		break;
	}
}*/


task autonomous() {
	lcdmode=1;
	forward(1000);
}

int lastl=0;
#define getBtns(a,b) ((vexRT[a]*-127)+(vexRT[b]*127))
float clawslow=1;
task usercontrol() {
	mode=0;
	lcdmode=2;
	while (true) {
		if ((!lastl)&&vexRT[Btn7R]!=lastl) {
			mode=!mode;
		}
		lastl=vexRT[Btn7R];
		motor[arm_left]=getBtns(Btn5D,Btn5U);
		motor[arm_right]=getBtns(Btn5D,Btn5U);
		if (getBtns(Btn6D,Btn6U)==0) {
			clawslow=1;
		} else {
			clawslow=clawslow*0.98;
		}
		motor[claw_grab]=getBtns(Btn6D,Btn6U)*clawslow;
		motor[claw_tilt]=getBtns(Btn8D,Btn8U);
		motor[claw_slide]=getBtns(Btn7D,Btn7U);
		switch (mode) {
			case 0: // normal tank controls
				motor[bottom_left]=vexRT[Ch3];
				motor[top_left]=vexRT[Ch3];
				motor[bottom_right]=vexRT[Ch2];
				motor[top_right]=vexRT[Ch2];
				motor[side_wheel]=getBtns(Btn8L,Btn8R);
			break;
			case 1: // left stick moves robot in four directions and right stick turns
				motor[side_wheel]=vexRT[Ch4];
				int turn=vexRT[Ch1];
				int fwd=vexRT[Ch3];
				motor[bottom_left]=fwd+turn;
				motor[top_left]=fwd+turn;
				motor[bottom_right]=fwd-turn;
				motor[top_right]=fwd-turn;
			break;
		}
		if (vexRT[Btn7L]) {
			forward(500);
			turnRight(90);
		}
		for (int i=0;i<9;i++) {
			if (abs(motor[i])<20) {
				motor[i]=0;
			}
		}
		wait1Msec(10);
	}
}
